# Assignment 2

141210026，宋奎熹

## 1. 复习，论述以下问题

### 1. 何谓 Cache？何谓 Buffer？各自的目的为何？

#### Cache

**缓存**区，是高速缓存，是位于 CPU 和主内存之间的容量较小但速度很快的存储器，因为 CPU 的速度远远高于主内存的速度，CPU 从内存中读取数据需等待很长的时间，而 Cache 保存着 CPU 刚用过的数据或循环使用的部分数据，这时从 Cache 中读取数据会更快，减少了 CPU 等待的时间，提高了系统的性能。

#### Buffer

**缓冲**区，用于存储速度不同步的设备或优先级不同的设备之间传输数据；通过 Buffer 可以减少进程间通信需要等待的时间，当存储速度快的设备与存储速度慢的设备进行通信时，存储慢的数据先把数据存放到 Buffer，达到一定程度存储快的设备再读取 Buffer 的数据，在此期间存储快的设备 CPU 可以干其他的事情。

#### 目的

Cache 并不是缓存文件的，而是缓存块的（块是 I/O 读写最小的单元）；Cache 一般会用在 I/O 请求上，如果多个进程要访问某个文件，可以把此文件读入 Cache 中，这样下一个进程获取 CPU 控制权并访问此文件直接从 Cache 读取，提高系统性能。

Buffer 一般是用在写入磁盘的，例如：某个进程要求多个字段被读入，当所有要求的字段被读入之前已经读入的字段会先放到 Buffer 中。

### 2. 何谓并发（Concurrent）？何谓并行（Parallel）？两者有何联系与区别？

#### 并发

以**可独立执行**的进程集合的方式编程（进程是出了名的难定义，这里是通常意义上的进程，不是 Linux 进程）。当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。

#### 并行

以**可同时执行**的（可能相关的）计算指令方式编程。当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行。

#### 联系和区别

在并发环境时，多线程不可能真正充分利用 CPU，节约运行时间，它只是以“挂起->执行->挂起”的方式以很小的时间片分别运行各个线程，给用户以每个线程都在运行的错觉。在这种环境中，多线程程序真正改善的是系统的响应性能和程序的友好性。
在并行环境中，一个时刻允许多个线程运行，这时多线程程序才真正充分利用了多 CPU 的处理能力，节省了整体的运行时间。在这种环境中，多线程程序能体现出它的四大优势：充分利用CPU，节省时间，改善响应和增加程序的友好性。

### 3. 何谓线程（Thread）？何谓进程（Process）？线程有哪些支持/实现方法？

#### 线程

是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

#### 进程

是计算机中已运行程序的实体。进程为曾经是分时系统的基本运作单位。在面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若干进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步（平行）的方式独立运行。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机体系结构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。

#### 线程的实现方法

* 用户级线程
* 内核级线程
* 组合方式

### 4. 何谓指令流水线（Instruction pipeline）？

#### 指令流水线

是为了让计算机和其它数字电子设备能够加速指令的通过速度（单位时间内被运行的指令数量）而设计的技术。

流水线在处理器的内部被组织成层级，各个层级的流水线能半独立地单独运作。每一个层级都被管理并且链接到一条“链”，因而每个层级的输出被送到其它层级直至任务完成。 处理器的这种组织方式能使总体的处理时间显著缩短。

## 2. 编程

查找 1 ~ N 之间的所有素数（N 可以为十万、一百万或一千万等）。先用串行程序，再分别将 其并行化（多线程程序，同时提供 `Windows API` 和 `POSIX Thread` 版），并在各自平台上对性能进行分析。

要求：给出源代码及性能分析的文档。（文档中需要给出程序运行的串行时间，并行时间，加速比，并对当前性能好坏的原因做一定的分析）

### 参数

搜索素数数字范围：0 ～ 4000000
指定线程数：11
虚拟机运行系统：macOS 10.14 Beta (18A314h)
虚拟机：Parallels Desktop 12.0.1 (41296)
Windows 系统：Windows 10 Enterprise (1607)
Linux 系统：Ubuntu 16.04.1 LTS

### Windows 下运行时间

```
--------------------Serial Number: 283146Serial Time: 6.99351--------------------Parallel Number: 283146Parallel Time: 2.09687--------------------
```

加速比 = 3.3352139141

### Linux 下运行时间

```
--------------------Serial Number: 283146Serial Time: 1.51363--------------------Parallel Number: 283146Parallel Time: 0.723971--------------------```

加速比 = 2.0907329161

### 分析

这里进行了两个考虑

1. 要把数据进行纵切，也即（仅示意，并非真实数据）：（1, 10001, 20001, 30001...）这样组织数据，而不是（1, 2, 3, 4...）。因为判断小的数字是否为素数的计算量远小于大的数字，所以要把数字均匀地分给各个线程。
2. 判断素数时，由于偶数占了数据中一半，所以可以首先判断该数是否为偶数（2 除外）。如果是，直接返回`false`；如果不是，再进行从 3 到 `sqrt(N)` 范围内的试除，而且步长可以调整为 2。这一定程度上加快了判断的过程。
